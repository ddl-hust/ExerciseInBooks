#### 类型成员(P243)
1. 定义：某种类型在类中的别名

eg. `typedef std::string::size_type pos`
 
也可以等价使用
`using pos=std::string::size_type`
2. 类型成员必须先定义后使用；(why)

3. 使用类的类型成员
通过作用域运算符(::)来访问，对于非模板代码，编译器掌握了类的定义，能够知道通过作用域运算符访问的名字是类型还是静态成员，
但对于模板代码就不行，必须在实例化阶段才能知道，
为了处理模板，编译器必须知道名字是否表示一个类型，比如Ｔ是一个模板参数，请看下面语句：
`T::size_type * p`
这个语句就有歧义，编译器不知道我们是定义一个　名为ｐ的指针变量，还是将静态数据成员与p相乘。

默认情况下，Ｃ++嘉定通过作用域运算符访问的名字不是类型，因此如果我们希望使用模板类型参数的类型成员，
必须显式指出。通过关键字`typename` 来实现：
```
template<typename T>
typename T::value_type top(const T&c) //显式指出返回值为类型
{
    pass
}
```

#### 默认模板实参(default template argument)
在Ｃ++11 可以为函数，类模板提供默认实参

与函数默认实参一样，对于模板参数，只有当他右侧的所有参数都有默认实参时候，他才可以有默认实参。


